## 源文件yuv4dec.h

### 第一个函数
1. av_cold:这是一个宏，通常用于标记那些只在初始化或者关闭时调用的函数，以便编译器进行优化。
2. AVCodecContext结构包含了解码器的上下文信息。
3. avctx->pix_fmt 这是AVCodecContext结构的一个字段，表示像素格式。
4. AV_PIX_FMT_YUV420P 这是一个枚举值，表示YUV 4:2:0的像素格式。
5. 这个函数的作用是初始化yuv4解码器，并设置其像素格式为YUV 4:2:0，成功返回0.

### 第二个函数 yuv4_decode_frame
1. 函数声明的变量avctx, 编解码器的上下文；AVFrame *pix, 一个空的帧，用于存储解码后的数据；int *got_frame, 一个指针，用于指示是否成功的解码了一帧；AVPacket *avpkt, 包含编码数据的数据包。
2. const uint8_t *src指向avpkt的常量指针。三个指针，指向y, u, v平面。
3. 在YUV4格式中，每个宏块（2×2）通常是是这样组织的
    - 2个字节的U数据
    - 2个字节的V数据
    - 2个自己的Y数据  
所以，为了解码整个帧，所需要的数据是：宏块的数量×6。
所以才有了这个判断。
```if(avpkt->size < 6 *(avctx->width + 1 >> 1) * (avctx->height + 1) >> 1)```  
这确保了数据包的大小至少是整个帧所需的最小数据量。
4. av_log(avctx, AV_LOG_ERROR, "..."),这是FFmpeg库中的一个日志函数，用于输出日志信息， AV_LOG_ERROR，表示日志级别，AVERROR,是一个宏，返回一个错误值，表示函数不能继续执行，因为它收到了无效的输入。
5. ff_get_buffer(avctx, pic, 0):
    - ff_get_buffer(avctx, pic, 0):用于为图像帧分配内存。avctx还是指向包含编解码器的上下文的信息。
    - pic是一个指向AVFrame的指针，该结构包含一个视频帧，这个函数将为这个帧分配内存。
    - 第三个参数0表示指定内存分配的方式，0表示使用默认的方式分配内存。
6. flags是AVFrame结构中的一个成员，它是一个位字段，用于存储帧的各种标志。AV_FRAME_FLAG_KEY是一个常量，是关键帧的标志，也较I帧，是视频压缩的一个概念，它是完全自包含的，不依赖于其它帧。关键帧通常比其它类型的帧（如P帧或B帧）大，但它们提供了视频压缩的起点。
    - 下一步的或运算操作是为视频帧设置一个标志，表明这是一个关键帧。
    - 接下来的设置Y、U、V的指针，指向帧的相应平面，并开始遍历每4个像素块，每4个Y才有一个U和一个V，Y的分辨率是完整的，U和V是Y的分辨率的一半。
    - 在遍历中，因为，某些YUV格式的数据，u和v的范围是-127-128，而其它的应该是0-255，所以需要先将其变成无符号的8位整数，之后分别从src中读取两行的Y的值。
    - 再更新y, u, v指针。
    - 最后说明成功解码一个帧，并返回已经处理了多少的数据。
7. 最后这个常量数据结构，描述了一个视频解码器，格式是未经压缩的420解码器
    - 名称为yuv4
    - 解的是4:2:)
    - 类型是解码器
    - 接下来是解码器的唯一标示符
    - 设置解码器的初始函数
    - 设置解码回调函数
    - 最后设置解码器的能力是支持直接渲染，即它可以直接将解码后的数据发给用户，而不需要复制。
